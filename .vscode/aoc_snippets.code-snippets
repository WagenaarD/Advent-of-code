{
    "aoc datetimestamp": {
        "prefix": "aoc datetimestamp",
        "body": [
            "$CURRENT_YEAR-$CURRENT_MONTH-$CURRENT_DATE $CURRENT_HOUR:$CURRENT_MINUTE:$CURRENT_SECOND",
        ]
    },

    "aoctimestamp": {
        "prefix": "aoctimestamp",
        "body": [
            "# $CURRENT_HOUR:$CURRENT_MINUTE:$CURRENT_SECOND",
        ]
    },

    "ADJ4": {
        "prefix": "ADJ4",
        "body": [
            "DIRS = [(-1, 0), (0, 1), (1, 0), (0, -1)]",
        ]
    },
    "ADJ4 Dict": {
        "prefix": "ADJ4 Dict",
        "body": [
            "DIRS = {'^': (-1, 0), '>': (0, 1), 'v': (1, 0), '<': (0, -1)}",
        ]
    },
    "ADJ8": {
        "prefix": "ADJ8",
        "body": [
            "DIRS = [(-1, 0), (-1, 1), (0, 1), (1, 1), (1, 0), (1, -1), (0, -1), (-1, -1)]",
        ]
    },
    "dims": {
        "prefix": "dims",
        "body": [
            "nrows, ncols = len(grid), len(grid[0])",
            "# nrows, ncols = input_txt.count('\\n')+1, input_txt.find('\\n')",
        ]
    },
    "grid_loop": {
        "prefix": "grid_loop",
        "body": [
            "nrows, ncols = len(grid), len(grid[0])",
            "for r, row in enumerate(grid):",
            "    for c, val in enumerate(row):",
            "        if not (r in range(nrows) and c in range(ncols)):",
            "            continue",
            "        ",
        ]
    },    
    "dijkstra": {
        "prefix": "Dijkstra",
        "body": [
            "def dijkstra(start: tuple[int, int]) -> dict[tuple[int, int], int]:",
            "    \"\"\"",
            "    Path storing Dijkstra algorithm. Dijkstra algorithm finds the shortest path from a starting ",
            "    state to any other state for positive pathlengths.",
            "    ",
            "    Algorithm will quite often need to be tailored before it can be applied. Common changes are:",
            "    - Allow for more complex states, such as the current direction or steps taken",
            "    - Allow for more complex costs between vertices",
            "    \"\"\"",
            "    qeue = [(0, start, ())]",
            "    seen = set()",
            "    dist = defaultdict(lambda: float('inf'))",
            "    dist[start] = 0",
            "    while qeue:",
            "        cost, pos, path = heapq.heappop(qeue)",
            "        if pos in seen:",
            "            continue",
            "        seen.add(pos)",
            "        path = (pos, path)",
            "        for dpos in DIRS:",
            "            npos = tuple_add(pos, dpos)",
            "            ncost = cost + 1 # Consider edges and consider obstacles",
            "            if npos in seen:",
            "                continue",
            "            if ncost < dist[npos]:",
            "                dist[npos] = ncost",
            "                heapq.heappush(qeue, (ncost, npos, path))",
            "    return dist",
        ],
    },

    "union find": {
        "prefix": "Union Find",
        "body": [
            "",
            "class UnionFind:",
            "    \"\"\"Union find algorithm for tracking connected groups.\"\"\"",
            "    def __init__(self, objects: list):",
            "        \"\"\"Objects can any list of hashable objects.\"\"\"",
            "        self.parent = {obj: obj for obj in objects}",
            "        \"\"\"Dictionary storing an object's parent. If the parent is itself, there is no parent\"\"\"",
            "        # self.no_groups = len(set(objects))",
            "        # \"\"\"Optional, tracks the number of unique groups. Needs to be uncommented from mix()\"\"\"",
            "    ",
            "    def find(self, object):",
            "        \"\"\"Finds the parent of the object. If the parent is multiple steps away, store the parent of ",
            "        the parent\"\"\"",
            "        if self.parent[object] == object:",
            "            return object",
            "        else:",
            "            self.parent[object] = self.find(self.parent[object])",
            "            return self.parent[object]",
            "    ",
            "    def mix(self, child, parent):",
            "        \"\"\"",
            "        Combine two objects by setting the parent of an object to the parent of another object",
            "        \"\"\"",
            "        # if self.find(child) != self.find(parent):",
            "        #     self.no_groups -= 1",
            "        self.parent[self.find(child)] = self.find(parent)"
        ]   
    },  

    "transpose list": {
        "prefix": "Transpose list",
        "body": "transposed_list = list(zip(*old_list))",
    }
}